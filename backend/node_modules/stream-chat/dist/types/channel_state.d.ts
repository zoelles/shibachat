import type { Channel } from './channel';
import type { ChannelMemberResponse, Event, LocalMessage, MessageResponse, MessageResponseBase, MessageSet, MessageSetType, PendingMessageResponse, ReactionResponse, UserResponse } from './types';
type ChannelReadStatus = Record<string, {
    last_read: Date;
    unread_messages: number;
    user: UserResponse;
    first_unread_message_id?: string;
    last_read_message_id?: string;
}>;
/**
 * ChannelState - A container class for the channel state.
 */
export declare class ChannelState {
    _channel: Channel;
    watcher_count: number;
    typing: Record<string, Event>;
    read: ChannelReadStatus;
    pinnedMessages: Array<ReturnType<ChannelState['formatMessage']>>;
    pending_messages: Array<PendingMessageResponse>;
    threads: Record<string, Array<ReturnType<ChannelState['formatMessage']>>>;
    mutedUsers: Array<UserResponse>;
    watchers: Record<string, UserResponse>;
    members: Record<string, ChannelMemberResponse>;
    unreadCount: number;
    membership: ChannelMemberResponse;
    last_message_at: Date | null;
    /**
     * Flag which indicates if channel state contain latest/recent messages or no.
     * This flag should be managed by UI sdks using a setter - setIsUpToDate.
     * When false, any new message (received by websocket event - message.new) will not
     * be pushed on to message list.
     */
    isUpToDate: boolean;
    /**
     * Disjoint lists of messages
     * Users can jump in the message list (with searching) and this can result in disjoint lists of messages
     * The state manages these lists and merges them when lists overlap
     * The messages array contains the currently active set
     */
    messageSets: MessageSet[];
    constructor(channel: Channel);
    get messages(): Array<ReturnType<ChannelState["formatMessage"]>>;
    set messages(messages: Array<ReturnType<ChannelState['formatMessage']>>);
    /**
     * The list of latest messages
     * The messages array not always contains the latest messages (for example if a user searched for an earlier message, that is in a different message set)
     */
    get latestMessages(): Array<ReturnType<ChannelState["formatMessage"]>>;
    set latestMessages(messages: Array<ReturnType<ChannelState['formatMessage']>>);
    get messagePagination(): {
        hasNext: boolean;
        hasPrev: boolean;
    };
    /**
     * addMessageSorted - Add a message to the state
     *
     * @param {MessageResponse} newMessage A new message
     * @param {boolean} timestampChanged Whether updating a message with changed created_at value.
     * @param {boolean} addIfDoesNotExist Add message if it is not in the list, used to prevent out of order updated messages from being added.
     * @param {MessageSetType} messageSetToAddToIfDoesNotExist Which message set to add to if message is not in the list (only used if addIfDoesNotExist is true)
     */
    addMessageSorted(newMessage: MessageResponse | LocalMessage, timestampChanged?: boolean, addIfDoesNotExist?: boolean, messageSetToAddToIfDoesNotExist?: MessageSetType): {
        messageSet: MessageSet;
    };
    /**
     * Takes the message object, parses the dates, sets `__html`
     * and sets the status to `received` if missing; returns a new message object.
     *
     * @param {MessageResponse} message `MessageResponse` object
     */
    formatMessage: (message: MessageResponse | MessageResponseBase | LocalMessage) => LocalMessage;
    /**
     * addMessagesSorted - Add the list of messages to state and resorts the messages
     *
     * @param {Array<MessageResponse>} newMessages A list of messages
     * @param {boolean} timestampChanged Whether updating messages with changed created_at value.
     * @param {boolean} initializing Whether channel is being initialized.
     * @param {boolean} addIfDoesNotExist Add message if it is not in the list, used to prevent out of order updated messages from being added.
     * @param {MessageSetType} messageSetToAddToIfDoesNotExist Which message set to add to if messages are not in the list (only used if addIfDoesNotExist is true)
     *
     */
    addMessagesSorted(newMessages: (MessageResponse | LocalMessage)[], timestampChanged?: boolean, initializing?: boolean, addIfDoesNotExist?: boolean, messageSetToAddToIfDoesNotExist?: MessageSetType): {
        messageSet: MessageSet;
    };
    /**
     * addPinnedMessages - adds messages in pinnedMessages property
     *
     * @param {Array<MessageResponse>} pinnedMessages A list of pinned messages
     *
     */
    addPinnedMessages(pinnedMessages: MessageResponse[]): void;
    /**
     * addPinnedMessage - adds message in pinnedMessages
     *
     * @param {MessageResponse} pinnedMessage message to update
     *
     */
    addPinnedMessage(pinnedMessage: MessageResponse): void;
    /**
     * removePinnedMessage - removes pinned message from pinnedMessages
     *
     * @param {MessageResponse} message message to remove
     *
     */
    removePinnedMessage(message: MessageResponse): void;
    addReaction(reaction: ReactionResponse, message?: MessageResponse, enforce_unique?: boolean): MessageResponse | LocalMessage | undefined;
    _addReactionToState(messageFromState: LocalMessage, reaction: ReactionResponse, enforce_unique?: boolean): LocalMessage;
    _addOwnReactionToMessage(ownReactions: ReactionResponse[] | null | undefined, reaction: ReactionResponse, enforce_unique?: boolean): ReactionResponse[];
    _removeOwnReactionFromMessage(ownReactions: ReactionResponse[] | null | undefined, reaction: ReactionResponse): ReactionResponse[] | null | undefined;
    removeReaction(reaction: ReactionResponse, message?: MessageResponse): MessageResponse | undefined;
    _removeReactionFromState(messageFromState: LocalMessage, reaction: ReactionResponse): LocalMessage;
    _updateQuotedMessageReferences({ message, remove, }: {
        message: MessageResponse;
        remove?: boolean;
    }): void;
    removeQuotedMessageReferences(message: MessageResponse): void;
    /**
     * Updates all instances of given message in channel state
     * @param message
     * @param updateFunc
     */
    _updateMessage(message: {
        id?: string;
        parent_id?: string;
        pinned?: boolean;
        show_in_channel?: boolean;
    }, updateFunc: (msg: ReturnType<ChannelState['formatMessage']>) => ReturnType<ChannelState['formatMessage']>): void;
    /**
     * Setter for isUpToDate.
     *
     * @param isUpToDate  Flag which indicates if channel state contain latest/recent messages or no.
     *                    This flag should be managed by UI sdks using a setter - setIsUpToDate.
     *                    When false, any new message (received by websocket event - message.new) will not
     *                    be pushed on to message list.
     */
    setIsUpToDate: (isUpToDate: boolean) => void;
    /**
     * _addToMessageList - Adds a message to a list of messages, tries to update first, appends if message isn't found
     *
     * @param {Array<ReturnType<ChannelState['formatMessage']>>} messages A list of messages
     * @param message
     * @param {boolean} timestampChanged Whether updating a message with changed created_at value.
     * @param {string} sortBy field name to use to sort the messages by
     * @param {boolean} addIfDoesNotExist Add message if it is not in the list, used to prevent out of order updated messages from being added.
     */
    _addToMessageList(messages: Array<ReturnType<ChannelState['formatMessage']>>, message: ReturnType<ChannelState['formatMessage']>, timestampChanged?: boolean, sortBy?: 'pinned_at' | 'created_at', addIfDoesNotExist?: boolean): LocalMessage[];
    /**
     * removeMessage - Description
     *
     * @param {{ id: string; parent_id?: string }} messageToRemove Object of the message to remove. Needs to have at id specified.
     *
     * @return {boolean} Returns if the message was removed
     */
    removeMessage(messageToRemove: {
        id: string;
        messageSetIndex?: number;
        parent_id?: string;
    }): boolean;
    removeMessageFromArray: (msgArray: Array<ReturnType<ChannelState["formatMessage"]>>, msg: {
        id: string;
        parent_id?: string;
    }) => {
        removed: boolean;
        result: LocalMessage[];
    };
    /**
     * Updates the message.user property with updated user object, for messages.
     *
     * @param {UserResponse} user
     */
    updateUserMessages: (user: UserResponse) => void;
    /**
     * Marks the messages as deleted, from deleted user.
     *
     * @param {UserResponse} user
     * @param {boolean} hardDelete
     */
    deleteUserMessages: (user: UserResponse, hardDelete?: boolean) => void;
    /**
     * filterErrorMessages - Removes error messages from the channel state.
     *
     */
    filterErrorMessages(): void;
    /**
     * clean - Remove stale data such as users that stayed in typing state for more than 5 seconds
     */
    clean(): void;
    clearMessages(): void;
    initMessages(): void;
    /**
     * loadMessageIntoState - Loads a given message (and messages around it) into the state
     *
     * @param {string} messageId The id of the message, or 'latest' to indicate switching to the latest messages
     * @param {string} parentMessageId The id of the parent message, if we want load a thread reply
     * @param {number} limit The page size if the message has to be queried from the server
     */
    loadMessageIntoState(messageId: string | 'latest', parentMessageId?: string, limit?: number): Promise<void>;
    /**
     * findMessage - Finds a message inside the state
     *
     * @param {string} messageId The id of the message
     * @param {string} parentMessageId The id of the parent message, if we want load a thread reply
     *
     * @return {ReturnType<ChannelState['formatMessage']>} Returns the message, or undefined if the message wasn't found
     */
    findMessage(messageId: string, parentMessageId?: string): LocalMessage | undefined;
    private switchToMessageSet;
    private areMessageSetsOverlap;
    private findMessageSetIndex;
    private findTargetMessageSet;
}
export {};
