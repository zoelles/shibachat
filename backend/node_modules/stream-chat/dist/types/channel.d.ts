import { ChannelState } from './channel_state';
import type { StreamChat } from './client';
import type { AIState, APIResponse, AscDesc, BanUserOptions, ChannelAPIResponse, ChannelData, ChannelMemberAPIResponse, ChannelMemberResponse, ChannelQueryOptions, ChannelResponse, ChannelUpdateOptions, CreateDraftResponse, DeleteChannelAPIResponse, DraftMessagePayload, Event, EventAPIResponse, EventHandler, EventTypes, GetDraftResponse, GetMultipleMessagesAPIResponse, GetReactionsAPIResponse, GetRepliesAPIResponse, LocalMessage, MarkReadOptions, MarkUnreadOptions, MemberFilters, MemberSort, Message, MessageFilters, MessageOptions, MessagePaginationOptions, MessageResponse, MessageSetType, MuteChannelAPIResponse, NewMemberPayload, PartialUpdateChannel, PartialUpdateChannelAPIResponse, PartialUpdateMember, PartialUpdateMemberAPIResponse, PinnedMessagePaginationOptions, PinnedMessagesSort, PollVoteData, PushPreference, QueryChannelAPIResponse, QueryMembersOptions, Reaction, ReactionAPIResponse, SearchAPIResponse, SearchOptions, SendMessageAPIResponse, SendMessageOptions, TruncateChannelAPIResponse, TruncateOptions, UpdateChannelAPIResponse, UpdateChannelOptions, UserResponse } from './types';
import type { Role } from './permissions';
import { MessageComposer } from './messageComposer';
/**
 * Channel - The Channel class manages it's own state.
 */
export declare class Channel {
    _client: StreamChat;
    type: string;
    id: string | undefined;
    data: Partial<ChannelData & ChannelResponse> | undefined;
    _data: Partial<ChannelData & ChannelResponse>;
    cid: string;
    /**  */
    listeners: {
        [key: string]: (string | EventHandler)[];
    };
    state: ChannelState;
    /**
     * This boolean is a vague indication of weather the channel exists on chat backend.
     *
     * If the value is true, then that means the channel has been initialized by either calling
     * channel.create() or channel.query() or channel.watch().
     *
     * If the value is false, then channel may or may not exist on the backend. The only way to ensure
     * is by calling channel.create() or channel.query() or channel.watch().
     */
    initialized: boolean;
    /**
     * Indicates weather channel has been initialized by manually populating the state with some messages, members etc.
     * Static state indicates that channel exists on backend, but is not being watched yet.
     */
    offlineMode: boolean;
    lastKeyStroke?: Date;
    lastTypingEvent: Date | null;
    isTyping: boolean;
    disconnected: boolean;
    push_preferences?: PushPreference;
    readonly messageComposer: MessageComposer;
    /**
     * constructor - Create a channel
     *
     * @param {StreamChat} client the chat client
     * @param {string} type  the type of channel
     * @param {string} [id]  the id of the chat
     * @param {ChannelData} data any additional custom params
     *
     * @return {Channel} Returns a new uninitialized channel
     */
    constructor(client: StreamChat, type: string, id: string | undefined, data: ChannelData);
    /**
     * getClient - Get the chat client for this channel. If client.disconnect() was called, this function will error
     *
     * @return {StreamChat}
     */
    getClient(): StreamChat;
    /**
     * getConfig - Get the config for this channel id (cid)
     *
     * @return {Record<string, unknown>}
     */
    getConfig(): import("./types").ChannelConfigWithInfo | undefined;
    /**
     * sendMessage - Send a message to this channel
     *
     * @param {Message} message The Message object
     * @param {boolean} [options.skip_enrich_url] Do not try to enrich the URLs within message
     * @param {boolean} [options.skip_push] Skip sending push notifications
     * @param {boolean} [options.is_pending_message] DEPRECATED, please use `pending` instead.
     * @param {boolean} [options.pending] Make this message pending
     * @param {Record<string,string>} [options.pending_message_metadata] Metadata for the pending message
     * @param {boolean} [options.force_moderation] Apply force moderation for server-side requests
     *
     * @return {Promise<SendMessageAPIResponse>} The Server Response
     */
    _sendMessage(message: Message, options?: SendMessageOptions): Promise<SendMessageAPIResponse>;
    sendMessage(message: Message, options?: SendMessageOptions): Promise<SendMessageAPIResponse>;
    sendFile(uri: string | NodeJS.ReadableStream | Buffer | File, name?: string, contentType?: string, user?: UserResponse): Promise<import("./types").SendFileAPIResponse>;
    sendImage(uri: string | NodeJS.ReadableStream | File, name?: string, contentType?: string, user?: UserResponse): Promise<import("./types").SendFileAPIResponse>;
    deleteFile(url: string): Promise<APIResponse>;
    deleteImage(url: string): Promise<APIResponse>;
    /**
     * sendEvent - Send an event on this channel
     *
     * @param {Event} event for example {type: 'message.read'}
     *
     * @return {Promise<EventAPIResponse>} The Server Response
     */
    sendEvent(event: Event): Promise<EventAPIResponse>;
    /**
     * search - Query messages
     *
     * @param {MessageFilters | string}  query search query or object MongoDB style filters
     * @param {{client_id?: string; connection_id?: string; query?: string; message_filter_conditions?: MessageFilters}} options Option object, {user_id: 'tommaso'}
     *
     * @return {Promise<SearchAPIResponse>} search messages response
     */
    search(query: MessageFilters | string, options?: SearchOptions & {
        client_id?: string;
        connection_id?: string;
        message_filter_conditions?: MessageFilters;
        message_options?: MessageOptions;
        query?: string;
    }): Promise<SearchAPIResponse>;
    /**
     * queryMembers - Query Members
     *
     * @param {MemberFilters}  filterConditions object MongoDB style filters
     * @param {MemberSort} [sort] Sort options, for instance [{created_at: -1}].
     * When using multiple fields, make sure you use array of objects to guarantee field order, for instance [{name: -1}, {created_at: 1}]
     * @param {{ limit?: number; offset?: number }} [options] Option object, {limit: 10, offset:10}
     *
     * @return {Promise<ChannelMemberAPIResponse>} Query Members response
     */
    queryMembers(filterConditions: MemberFilters, sort?: MemberSort, options?: QueryMembersOptions): Promise<ChannelMemberAPIResponse>;
    /**
     * updateMemberPartial - Partial update a member
     *
     * @param {PartialUpdateMember}  updates
     * @param {{ user_id?: string }} [options] Option object, {user_id: 'jane'} to optionally specify the user id
  
     * @return {Promise<ChannelMemberResponse>} Updated member
     */
    updateMemberPartial(updates: PartialUpdateMember, options?: {
        userId?: string;
    }): Promise<PartialUpdateMemberAPIResponse>;
    /**
     * @deprecated Use `updateMemberPartial` instead
     * partialUpdateMember - Partial update a member
     *
     * @param {string} user_id member user id
     * @param {PartialUpdateMember}  updates
     *
     * @return {Promise<ChannelMemberResponse>} Updated member
     */
    partialUpdateMember(user_id: string, updates: PartialUpdateMember): Promise<PartialUpdateMemberAPIResponse>;
    /**
     * sendReaction - Sends a reaction to a message. If offline support is enabled, it will make sure
     * that sending the reaction is queued up if it fails due to bad internet conditions and executed
     * later.
     *
     * @param {string} messageID the message id
     * @param {Reaction} reaction the reaction object for instance {type: 'love'}
     * @param {{ enforce_unique?: boolean, skip_push?: boolean }} [options] Option object, {enforce_unique: true, skip_push: true} to override any existing reaction or skip sending push notifications
     *
     * @return {Promise<ReactionAPIResponse>} The Server Response
     */
    sendReaction(messageID: string, reaction: Reaction, options?: {
        enforce_unique?: boolean;
        skip_push?: boolean;
    }): Promise<ReactionAPIResponse>;
    /**
     * sendReaction - Send a reaction about a message
     *
     * @param {string} messageID the message id
     * @param {Reaction} reaction the reaction object for instance {type: 'love'}
     * @param {{ enforce_unique?: boolean, skip_push?: boolean }} [options] Option object, {enforce_unique: true, skip_push: true} to override any existing reaction or skip sending push notifications
     *
     * @return {Promise<ReactionAPIResponse>} The Server Response
     */
    _sendReaction(messageID: string, reaction: Reaction, options?: {
        enforce_unique?: boolean;
        skip_push?: boolean;
    }): Promise<ReactionAPIResponse>;
    deleteReaction(messageID: string, reactionType: string, user_id?: string): Promise<ReactionAPIResponse>;
    /**
     * deleteReaction - Delete a reaction by user and type
     *
     * @param {string} messageID the id of the message from which te remove the reaction
     * @param {string} reactionType the type of reaction that should be removed
     * @param {string} [user_id] the id of the user (used only for server side request) default null
     *
     * @return {Promise<ReactionAPIResponse>} The Server Response
     */
    _deleteReaction(messageID: string, reactionType: string, user_id?: string): Promise<ReactionAPIResponse>;
    /**
     * update - Edit the channel's custom properties
     *
     * @param {ChannelData} channelData The object to update the custom properties of this channel with
     * @param {Message} [updateMessage] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    update(channelData?: Partial<ChannelData & ChannelResponse>, updateMessage?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * updatePartial - partial update channel properties
     *
     * @param {PartialUpdateChannel} partial update request
     *
     * @return {Promise<PartialUpdateChannelAPIResponse>}
     */
    updatePartial(update: PartialUpdateChannel): Promise<PartialUpdateChannelAPIResponse>;
    /**
     * enableSlowMode - enable slow mode
     *
     * @param {number} coolDownInterval the cooldown interval in seconds
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    enableSlowMode(coolDownInterval: number): Promise<UpdateChannelAPIResponse>;
    /**
     * disableSlowMode - disable slow mode
     *
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    disableSlowMode(): Promise<UpdateChannelAPIResponse>;
    /**
     * delete - Delete the channel. Messages are permanently removed.
     *
     * @param {boolean} [options.hard_delete] Defines if the channel is hard deleted or not
     *
     * @return {Promise<DeleteChannelAPIResponse>} The server response
     */
    delete(options?: {
        hard_delete?: boolean;
    }): Promise<DeleteChannelAPIResponse>;
    /**
     * truncate - Removes all messages from the channel
     * @param {TruncateOptions} [options] Defines truncation options
     * @return {Promise<TruncateChannelAPIResponse>} The server response
     */
    truncate(options?: TruncateOptions): Promise<TruncateChannelAPIResponse>;
    /**
     * acceptInvite - accept invitation to the channel
     *
     * @param {UpdateChannelOptions} [options] The object to update the custom properties of this channel with
     *
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    acceptInvite(options?: UpdateChannelOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * rejectInvite - reject invitation to the channel
     *
     * @param {UpdateChannelOptions} [options] The object to update the custom properties of this channel with
     *
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    rejectInvite(options?: UpdateChannelOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * addMembers - add members to the channel
     *
     * @param {string[] | Array<NewMemberPayload>} members An array of members to add to the channel
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    addMembers(members: string[] | Array<NewMemberPayload>, message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * addModerators - add moderators to the channel
     *
     * @param {string[]} members An array of member identifiers
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    addModerators(members: string[], message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * assignRoles - sets member roles in a channel
     *
     * @param {{channel_role: Role, user_id: string}[]} roles List of role assignments
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    assignRoles(roles: {
        channel_role: Role;
        user_id: string;
    }[], message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * inviteMembers - invite members to the channel
     *
     * @param {string[] | Array<NewMemberPayload>} members An array of members to invite to the channel
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    inviteMembers(members: string[] | Required<Omit<NewMemberPayload, 'channel_role'>>[], message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * removeMembers - remove members from channel
     *
     * @param {string[]} members An array of member identifiers
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    removeMembers(members: string[], message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * demoteModerators - remove moderator role from channel members
     *
     * @param {string[]} members An array of member identifiers
     * @param {Message} [message] Optional message object for channel members notification
     * @param {ChannelUpdateOptions} [options] Option object, configuration to control the behavior while updating
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     */
    demoteModerators(members: string[], message?: Message, options?: ChannelUpdateOptions): Promise<UpdateChannelAPIResponse>;
    /**
     * _update - executes channel update request
     * @param payload Object Update Channel payload
     * @return {Promise<UpdateChannelAPIResponse>} The server response
     * TODO: introduce new type instead of Object in the next major update
     */
    _update(payload: object): Promise<UpdateChannelAPIResponse>;
    /**
     * mute - mutes the current channel
     * @param {{ user_id?: string, expiration?: string }} opts expiration in minutes or user_id
     * @return {Promise<MuteChannelAPIResponse>} The server response
     *
     * example with expiration:
     * await channel.mute({expiration: moment.duration(2, 'weeks')});
     *
     * example server side:
     * await channel.mute({user_id: userId});
     *
     */
    mute(opts?: {
        expiration?: number;
        user_id?: string;
    }): Promise<MuteChannelAPIResponse>;
    /**
     * unmute - mutes the current channel
     * @param {{ user_id?: string}} opts user_id
     * @return {Promise<APIResponse>} The server response
     *
     * example server side:
     * await channel.unmute({user_id: userId});
     */
    unmute(opts?: {
        user_id?: string;
    }): Promise<APIResponse>;
    /**
     * archive - archives the current channel
     * @param {{ user_id?: string }} opts user_id if called server side
     * @return {Promise<ChannelMemberResponse>} The server response
     *
     * example:
     * await channel.archives();
     *
     * example server side:
     * await channel.archive({user_id: userId});
     *
     */
    archive(opts?: {
        user_id?: string;
    }): Promise<ChannelMemberResponse>;
    /**
     * unarchive - unarchives the current channel
     * @param {{ user_id?: string }} opts user_id if called server side
     * @return {Promise<ChannelMemberResponse>} The server response
     *
     * example:
     * await channel.unarchive();
     *
     * example server side:
     * await channel.unarchive({user_id: userId});
     *
     */
    unarchive(opts?: {
        user_id?: string;
    }): Promise<ChannelMemberResponse>;
    /**
     * pin - pins the current channel
     * @param {{ user_id?: string }} opts user_id if called server side
     * @return {Promise<ChannelMemberResponse>} The server response
     *
     * example:
     * await channel.pin();
     *
     * example server side:
     * await channel.pin({user_id: userId});
     *
     */
    pin(opts?: {
        user_id?: string;
    }): Promise<ChannelMemberResponse>;
    /**
     * unpin - unpins the current channel
     * @param {{ user_id?: string }} opts user_id if called server side
     * @return {Promise<ChannelMemberResponse>} The server response
     *
     * example:
     * await channel.unpin();
     *
     * example server side:
     * await channel.unpin({user_id: userId});
     *
     */
    unpin(opts?: {
        user_id?: string;
    }): Promise<ChannelMemberResponse>;
    /**
     * muteStatus - returns the mute status for the current channel
     * @return {{ muted: boolean; createdAt: Date | null; expiresAt: Date | null }} { muted: true | false, createdAt: Date | null, expiresAt: Date | null}
     */
    muteStatus(): {
        createdAt: Date | null;
        expiresAt: Date | null;
        muted: boolean;
    };
    sendAction(messageID: string, formData: Record<string, string>): Promise<SendMessageAPIResponse>;
    /**
     * keystroke - First of the typing.start and typing.stop events based on the users keystrokes.
     * Call this on every keystroke
     * @see {@link https://getstream.io/chat/docs/typing_indicators/?language=js|Docs}
     * @param {string} [parent_id] set this field to `message.id` to indicate that typing event is happening in a thread
     */
    keystroke(parent_id?: string, options?: {
        user_id: string;
    }): Promise<void>;
    /**
     * Sends an event to update the AI state for a specific message.
     * Typically used by the server connected to the AI service to notify clients of state changes.
     *
     * @param messageId - The ID of the message associated with the AI state.
     * @param state - The new state of the AI process (e.g., thinking, generating).
     * @param options - Optional parameters, such as `ai_message`, to include additional details in the event.
     */
    updateAIState(messageId: string, state: AIState, options?: {
        ai_message?: string;
    }): Promise<void>;
    /**
     * Sends an event to notify watchers to clear the typing/thinking UI when the AI response starts streaming.
     * Typically used by the server connected to the AI service to inform clients that the AI response has started.
     */
    clearAIIndicator(): Promise<void>;
    /**
     * Sends an event to stop AI response generation, leaving the message in its current state.
     * Triggered by the user to halt the AI response process.
     */
    stopAIResponse(): Promise<void>;
    /**
     * stopTyping - Sets last typing to null and sends the typing.stop event
     * @see {@link https://getstream.io/chat/docs/typing_indicators/?language=js|Docs}
     * @param {string} [parent_id] set this field to `message.id` to indicate that typing event is happening in a thread
     */
    stopTyping(parent_id?: string, options?: {
        user_id: string;
    }): Promise<void>;
    _isTypingIndicatorsEnabled(): boolean;
    /**
     * lastMessage - return the last message, takes into account that last few messages might not be perfectly sorted
     *
     * @return {ReturnType<ChannelState['formatMessage']> | undefined} Description
     */
    lastMessage(): LocalMessage | undefined;
    /**
     * markRead - Send the mark read event for this user, only works if the `read_events` setting is enabled
     *
     * @param {MarkReadOptions} data
     * @return {Promise<EventAPIResponse | null>} Description
     */
    markRead(data?: MarkReadOptions): Promise<EventAPIResponse | null>;
    /**
     * markUnread - Mark the channel as unread from messageID, only works if the `read_events` setting is enabled
     *
     * @param {MarkUnreadOptions} data
     * @return {APIResponse} An API response
     */
    markUnread(data: MarkUnreadOptions): Promise<APIResponse | null>;
    /**
     * clean - Cleans the channel state and fires stop typing if needed
     */
    clean(): void;
    /**
     * watch - Loads the initial channel state and watches for changes
     *
     * @param {ChannelQueryOptions} options additional options for the query endpoint
     *
     * @return {Promise<QueryChannelAPIResponse>} The server response
     */
    watch(options?: ChannelQueryOptions): Promise<QueryChannelAPIResponse>;
    /**
     * stopWatching - Stops watching the channel
     *
     * @return {Promise<APIResponse>} The server response
     */
    stopWatching(): Promise<APIResponse>;
    /**
     * getReplies - List the message replies for a parent message.
     *
     * The recommended way of working with threads is to use the Thread class.
     *
     * @param {string} parent_id The message parent id, ie the top of the thread
     * @param {MessagePaginationOptions & { user?: UserResponse; user_id?: string }} options Pagination params, ie {limit:10, id_lte: 10}
     *
     * @return {Promise<GetRepliesAPIResponse>} A response with a list of messages
     */
    getReplies(parent_id: string, options: MessagePaginationOptions & {
        user?: UserResponse;
        user_id?: string;
    }, sort?: {
        created_at: AscDesc;
    }[]): Promise<GetRepliesAPIResponse>;
    /**
     * getPinnedMessages - List list pinned messages of the channel
     *
     * @param {PinnedMessagePaginationOptions & { user?: UserResponse; user_id?: string }} options Pagination params, ie {limit:10, id_lte: 10}
     * @param {PinnedMessagesSort} sort defines sorting direction of pinned messages
     *
     * @return {Promise<GetRepliesAPIResponse>} A response with a list of messages
     */
    getPinnedMessages(options: PinnedMessagePaginationOptions & {
        user?: UserResponse;
        user_id?: string;
    }, sort?: PinnedMessagesSort): Promise<GetRepliesAPIResponse>;
    /**
     * getReactions - List the reactions, supports pagination
     *
     * @param {string} message_id The message id
     * @param {{ limit?: number; offset?: number }} options The pagination options
     *
     * @return {Promise<GetReactionsAPIResponse>} Server response
     */
    getReactions(message_id: string, options: {
        limit?: number;
        offset?: number;
    }): Promise<GetReactionsAPIResponse>;
    /**
     * getMessagesById - Retrieves a list of messages by ID
     *
     * @param {string[]} messageIds The ids of the messages to retrieve from this channel
     *
     * @return {Promise<GetMultipleMessagesAPIResponse>} Server response
     */
    getMessagesById(messageIds: string[]): Promise<GetMultipleMessagesAPIResponse>;
    /**
     * lastRead - returns the last time the user marked the channel as read if the user never marked the channel as read, this will return null
     * @return {Date | null | undefined}
     */
    lastRead(): Date | null | undefined;
    _countMessageAsUnread(message: LocalMessage | MessageResponse): boolean;
    /**
     * countUnread - Count of unread messages
     *
     * @param {Date | null} [lastRead] lastRead the time that the user read a message, defaults to current user's read state
     *
     * @return {number} Unread count
     */
    countUnread(lastRead?: Date | null): number;
    /**
     * countUnreadMentions - Count the number of unread messages mentioning the current user
     *
     * @return {number} Unread mentions count
     */
    countUnreadMentions(): number;
    /**
     * create - Creates a new channel
     *
     * @return {Promise<QueryChannelAPIResponse>} The Server Response
     *
     */
    create: (options?: ChannelQueryOptions) => Promise<QueryChannelAPIResponse>;
    /**
     * query - Query the API, get messages, members or other channel fields
     *
     * @param {ChannelQueryOptions} options The query options
     * @param {MessageSetType} messageSetToAddToIfDoesNotExist It's possible to load disjunct sets of a channel's messages into state, use `current` to load the initial channel state or if you want to extend the currently displayed messages, use `latest` if you want to load/extend the latest messages, `new` is used for loading a specific message and it's surroundings
     *
     * @return {Promise<QueryChannelAPIResponse>} Returns a query response
     */
    query(options?: ChannelQueryOptions, messageSetToAddToIfDoesNotExist?: MessageSetType): Promise<QueryChannelAPIResponse>;
    /**
     * banUser - Bans a user from a channel
     *
     * @param {string} targetUserID
     * @param {BanUserOptions} options
     * @returns {Promise<APIResponse>}
     */
    banUser(targetUserID: string, options: BanUserOptions): Promise<APIResponse>;
    /**
     * hides the channel from queryChannels for the user until a message is added
     * If clearHistory is set to true - all messages will be removed for the user
     *
     * @param {string | null} userId
     * @param {boolean} clearHistory
     * @returns {Promise<APIResponse>}
     */
    hide(userId?: string | null, clearHistory?: boolean): Promise<APIResponse>;
    /**
     * removes the hidden status for a channel
     *
     * @param {string | null} userId
     * @returns {Promise<APIResponse>}
     */
    show(userId?: string | null): Promise<APIResponse>;
    /**
     * unbanUser - Removes the bans for a user on a channel
     *
     * @param {string} targetUserID
     * @returns {Promise<APIResponse>}
     */
    unbanUser(targetUserID: string): Promise<APIResponse>;
    /**
     * shadowBan - Shadow bans a user from a channel
     *
     * @param {string} targetUserID
     * @param {BanUserOptions} options
     * @returns {Promise<APIResponse>}
     */
    shadowBan(targetUserID: string, options: BanUserOptions): Promise<APIResponse>;
    /**
     * removeShadowBan - Removes the shadow ban for a user on a channel
     *
     * @param {string} targetUserID
     * @returns {Promise<APIResponse>}
     */
    removeShadowBan(targetUserID: string): Promise<APIResponse>;
    /**
     * Cast or cancel one or more votes on a poll
     * @param pollId string The poll id
     * @param votes PollVoteData[] The votes that will be casted (or canceled in case of an empty array)
     * @returns {APIResponse & PollVoteResponse} The poll votes
     */
    vote(messageId: string, pollId: string, vote: PollVoteData): Promise<APIResponse & import("./types").CastVoteAPIResponse>;
    removeVote(messageId: string, pollId: string, voteId: string): Promise<APIResponse & {
        vote: import("./types").PollVote;
    }>;
    /**
     * createDraft - Creates or updates a draft message in a channel
     *
     * @param {DraftMessagePayload} message The draft message to create or update
     *
     * @return {Promise<CreateDraftResponse>} Response containing the created draft
     */
    _createDraft(message: DraftMessagePayload): Promise<CreateDraftResponse>;
    /**
     * createDraft - Creates or updates a draft message in a channel. If offline support is
     * enabled, it will make sure that creating the draft is queued up if it fails due to
     * bad internet conditions and executed later.
     *
     * @param {DraftMessagePayload} message The draft message to create or update
     *
     * @return {Promise<CreateDraftResponse>} Response containing the created draft
     */
    createDraft(message: DraftMessagePayload): Promise<CreateDraftResponse>;
    /**
     * deleteDraft - Deletes a draft message from a channel or a thread.
     *
     * @param {Object} options
     * @param {string} options.parent_id Optional parent message ID for drafts in threads
     *
     * @return {Promise<APIResponse>} API response
     */
    _deleteDraft({ parent_id }?: {
        parent_id?: string;
    }): Promise<APIResponse>;
    /**
     * deleteDraft - Deletes a draft message from a channel or a thread. If offline support is
     * enabled, it will make sure that deleting the draft is queued up if it fails due to
     * bad internet conditions and executed later.
     *
     * @param {Object} options
     * @param {string} options.parent_id Optional parent message ID for drafts in threads
     *
     * @return {Promise<APIResponse>} API response
     */
    deleteDraft(options?: {
        parent_id?: string;
    }): Promise<APIResponse>;
    /**
     * getDraft - Retrieves a draft message from a channel
     *
     * @param {Object} options
     * @param {string} options.parent_id Optional parent message ID for drafts in threads
     *
     * @return {Promise<GetDraftResponse>} Response containing the draft
     */
    getDraft({ parent_id }?: {
        parent_id?: string;
    }): Promise<GetDraftResponse>;
    /**
     * on - Listen to events on this channel.
     *
     * channel.on('message.new', event => {console.log("my new message", event, channel.state.messages)})
     * or
     * channel.on(event => {console.log(event.type)})
     *
     * @param {EventHandler | EventTypes} callbackOrString  The event type to listen for (optional)
     * @param {EventHandler} [callbackOrNothing] The callback to call
     */
    on(eventType: EventTypes, callback: EventHandler): {
        unsubscribe: () => void;
    };
    on(callback: EventHandler): {
        unsubscribe: () => void;
    };
    /**
     * off - Remove the event handler
     *
     */
    off(eventType: EventTypes, callback: EventHandler): void;
    off(callback: EventHandler): void;
    _handleChannelEvent(event: Event): void;
    _callChannelListeners: (event: Event) => void;
    /**
     * _channelURL - Returns the channel url
     *
     * @return {string} The channel url
     */
    _channelURL: () => string;
    _checkInitialized(): void;
    _initializeState(state: ChannelAPIResponse, messageSetToAddToIfDoesNotExist?: MessageSetType): {
        messageSet: import("./types").MessageSet;
    };
    _extendEventWithOwnReactions(event: Event): void;
    _hydrateMembers({ members, overrideCurrentState, }: {
        members: ChannelMemberResponse[];
        /**
         * If set to `true` then `ChannelState.members` will be overriden with the newly
         * provided `members`, setting this property to `false` will merge current `ChannelState.members`
         * object with the newly provided `members`
         * (new members with the same `userId` will replace the old ones).
         */
        overrideCurrentState?: boolean;
    }): void;
    _disconnect(): void;
}
