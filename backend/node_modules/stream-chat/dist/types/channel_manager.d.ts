import type { StreamChat } from './client';
import type { ChannelFilters, ChannelOptions, ChannelSort, ChannelStateOptions, Event } from './types';
import type { ValueOrPatch } from './store';
import { StateStore } from './store';
import type { Channel } from './channel';
import { WithSubscriptions } from './utils/WithSubscriptions';
export type ChannelManagerPagination = {
    filters: ChannelFilters;
    hasNext: boolean;
    isLoading: boolean;
    isLoadingNext: boolean;
    options: ChannelOptions;
    sort: ChannelSort;
};
export type ChannelManagerState = {
    channels: Channel[];
    /**
     * This value will become true the first time queryChannels is successfully executed and
     * will remain false otherwise. It's used as a control property regarding whether the list
     * has been initialized yet (i.e a query has already been done at least once) or not. We do
     * this to prevent state.channels from being forced to be nullable.
     */
    initialized: boolean;
    pagination: ChannelManagerPagination;
    error: Error | undefined;
};
export type ChannelSetterParameterType = ValueOrPatch<ChannelManagerState['channels']>;
export type ChannelSetterType = (arg: ChannelSetterParameterType) => void;
export type GenericEventHandlerType<T extends unknown[]> = (...args: T) => void | (() => void) | ((...args: T) => Promise<void>) | Promise<void>;
export type EventHandlerType = GenericEventHandlerType<[Event]>;
export type EventHandlerOverrideType = GenericEventHandlerType<[
    ChannelSetterType,
    Event
]>;
export type ChannelManagerEventTypes = 'notification.added_to_channel' | 'notification.message_new' | 'notification.removed_from_channel' | 'message.new' | 'member.updated' | 'channel.deleted' | 'channel.hidden' | 'channel.truncated' | 'channel.visible' | 'channel.updated';
export type ChannelManagerEventHandlerNames = 'channelDeletedHandler' | 'channelHiddenHandler' | 'channelTruncatedHandler' | 'channelUpdatedHandler' | 'channelVisibleHandler' | 'newMessageHandler' | 'memberUpdatedHandler' | 'notificationAddedToChannelHandler' | 'notificationNewMessageHandler' | 'notificationRemovedFromChannelHandler';
export type ChannelManagerEventHandlerOverrides = Partial<Record<ChannelManagerEventHandlerNames, EventHandlerOverrideType>>;
export type ExecuteChannelsQueryPayload = Pick<ChannelManagerPagination, 'filters' | 'sort' | 'options'> & {
    stateOptions: ChannelStateOptions;
};
export declare const channelManagerEventToHandlerMapping: {
    [key in ChannelManagerEventTypes]: ChannelManagerEventHandlerNames;
};
export type ChannelManagerOptions = {
    /**
     * Aborts a channels query that is already in progress and runs the new one.
     */
    abortInFlightQuery?: boolean;
    /**
     * Allows channel promotion to be applied where applicable for channels that are
     * currently not part of the channel list within the state. A good example of
     * this would be a channel that is being watched and it receives a new message,
     * but is not part of the list initially.
     */
    allowNotLoadedChannelPromotionForEvent?: {
        'channel.visible': boolean;
        'message.new': boolean;
        'notification.added_to_channel': boolean;
        'notification.message_new': boolean;
    };
    /**
     * Allows us to lock the order of channels within the list. Any event that would
     * change the order of channels within the list will do nothing.
     */
    lockChannelOrder?: boolean;
};
export declare const DEFAULT_CHANNEL_MANAGER_OPTIONS: {
    abortInFlightQuery: boolean;
    allowNotLoadedChannelPromotionForEvent: {
        'channel.visible': boolean;
        'message.new': boolean;
        'notification.added_to_channel': boolean;
        'notification.message_new': boolean;
    };
    lockChannelOrder: boolean;
};
export declare const DEFAULT_CHANNEL_MANAGER_PAGINATION_OPTIONS: {
    limit: number;
    offset: number;
};
/**
 * A class that manages a list of channels and changes it based on configuration and WS events. The
 * list of channels is reactive as well as the pagination and it can be subscribed to for state updates.
 *
 * @internal
 */
export declare class ChannelManager extends WithSubscriptions {
    readonly state: StateStore<ChannelManagerState>;
    private client;
    private eventHandlers;
    private eventHandlerOverrides;
    private options;
    private stateOptions;
    private id;
    constructor({ client, eventHandlerOverrides, options, }: {
        client: StreamChat;
        eventHandlerOverrides?: ChannelManagerEventHandlerOverrides;
        options?: ChannelManagerOptions;
    });
    setChannels: (valueOrFactory: ChannelSetterParameterType) => void;
    setEventHandlerOverrides: (eventHandlerOverrides?: ChannelManagerEventHandlerOverrides) => void;
    setOptions: (options?: ChannelManagerOptions) => void;
    private executeChannelsQuery;
    queryChannels: (filters: ChannelFilters, sort?: ChannelSort, options?: ChannelOptions, stateOptions?: ChannelStateOptions) => Promise<void>;
    loadNext: () => Promise<void>;
    private notificationAddedToChannelHandler;
    private channelDeletedHandler;
    private channelHiddenHandler;
    private newMessageHandler;
    private notificationNewMessageHandler;
    private channelVisibleHandler;
    private notificationRemovedFromChannelHandler;
    private memberUpdatedHandler;
    private subscriptionOrOverride;
    registerSubscriptions: () => void;
}
