export type InsertPosition = {
    after: string;
    before?: never;
} | {
    after?: never;
    before: string;
};
export type MiddlewareStatus = 'complete' | 'discard';
export type MiddlewareExecutionResult<TValue> = {
    state: TValue;
    status?: MiddlewareStatus;
};
export type ExecuteParams<TValue> = {
    eventName: string;
    initialValue: TValue;
};
export type MiddlewareHandlerParams<TValue> = {
    state: TValue;
    next: (state: TValue) => Promise<MiddlewareExecutionResult<TValue>>;
    complete: (state: TValue) => Promise<MiddlewareExecutionResult<TValue>>;
    discard: () => Promise<MiddlewareExecutionResult<TValue>>;
    forward: () => Promise<MiddlewareExecutionResult<TValue>>;
};
export type MiddlewareHandler<TValue> = (params: MiddlewareHandlerParams<TValue>) => Promise<MiddlewareExecutionResult<TValue>>;
export type MiddlewareHandlers<TValue, THandlers extends string> = {
    [K in THandlers]: MiddlewareHandler<TValue>;
};
export type Middleware<TValue, THandlers extends string> = {
    id: string;
    handlers: MiddlewareHandlers<TValue, THandlers>;
};
export declare class MiddlewareExecutor<TValue, THandlers extends string> {
    readonly id: string;
    private middleware;
    constructor();
    use(middleware: Middleware<TValue, THandlers> | Middleware<TValue, THandlers>[]): this;
    replace(middleware: Middleware<TValue, THandlers>[]): this;
    insert({ middleware, position, unique, }: {
        middleware: Middleware<TValue, THandlers>[];
        position: InsertPosition;
        unique?: boolean;
    }): this;
    setOrder(order: string[]): void;
    protected executeMiddlewareChain({ eventName, initialValue, }: ExecuteParams<TValue>): Promise<MiddlewareExecutionResult<TValue>>;
    execute({ eventName, initialValue: initialState, }: ExecuteParams<TValue>): Promise<MiddlewareExecutionResult<TValue>>;
}
